<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penalties Quality Analyzer</title>

    <!-- Google Fonts with system fallback -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Timing Design System z GitHub Pages -->
    <link rel="stylesheet" href="https://opencanoetiming.github.io/timing-design-system/dist/timing.min.css">

    <style>
        /* Override fonts - Google Fonts instead of self-hosted */
        :root {
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Loading spinner */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--color-border);
            border-radius: 50%;
            border-top-color: var(--color-accent);
            animation: spin 1s ease-in-out infinite;
            margin-left: var(--space-2);
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Level-based colors for penalty analysis */
        .level-0 { background-color: var(--color-bg-surface); }
        .level-1 { background-color: rgba(255, 149, 0, 0.15); }
        .level-2 { background-color: rgba(255, 149, 0, 0.25); }
        .level-3 { background-color: rgba(255, 149, 0, 0.40); }
        .level-4 { background-color: rgba(255, 59, 48, 0.30); }
        .level-5 { background-color: rgba(255, 59, 48, 0.50); }

        /* Light theme level colors */
        .theme-light .level-1,
        :root:not(.theme-dark) .level-1 { background-color: rgba(217, 119, 6, 0.15); }
        .theme-light .level-2,
        :root:not(.theme-dark) .level-2 { background-color: rgba(217, 119, 6, 0.25); }
        .theme-light .level-3,
        :root:not(.theme-dark) .level-3 { background-color: rgba(217, 119, 6, 0.40); }
        .theme-light .level-4,
        :root:not(.theme-dark) .level-4 { background-color: rgba(220, 38, 38, 0.30); }
        .theme-light .level-5,
        :root:not(.theme-dark) .level-5 { background-color: rgba(220, 38, 38, 0.50); }

        /* Dropzone text */
        .dropzone p {
            margin-top: var(--space-2);
            color: var(--color-text-muted);
        }

        /* Race row styling */
        .race-row td:first-child {
            font-weight: var(--font-medium);
            text-align: left;
        }

        /* Separator row */
        .separator-row td {
            height: var(--space-2);
            background-color: var(--color-bg-body);
            border: none;
        }

        /* Results section */
        #results {
            margin-top: var(--space-6);
        }

        #results h2 {
            margin-bottom: var(--space-2);
        }

        #results p {
            color: var(--color-text-secondary);
            margin-bottom: var(--space-4);
        }

        /* Table container for horizontal scroll */
        .table-responsive {
            margin-top: var(--space-4);
        }

        /* Gate cell */
        .gate-cell {
            text-align: center;
            min-width: 40px;
        }

        /* Copy button spacing */
        .copy-button {
            margin-bottom: var(--space-4);
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="card">
            <div class="card-body">
                <h1>Canoe Race Penalties Quality Analysis</h1>

                <div class="dropzone" id="dropZone">
                    <label for="xmlFile" class="btn btn-primary">Select file</label>
                    <input type="file" id="xmlFile" accept=".xml" style="display: none;">
                    <p>or drag and drop file here</p>
                </div>

                <div id="uploadStatus" class="alert" style="display: none;"></div>

                <div id="results" style="display: none;">
                    <h2>Analysis Results</h2>
                    <p>Number of detected ex-post corrections by gates and races</p>

                    <button id="copyToClipboard" class="btn btn-secondary copy-button">Copy table to clipboard</button>
                    <div class="table-responsive">
                        <table id="resultsTable" class="table table-striped table-hover">
                            <!-- Table will be populated dynamically -->
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let xmlData = null;
        let parsedData = {
            results: [],
            courseConfigs: {},
            scheduleInfo: {}
        };

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('xmlFile');
        const uploadStatus = document.getElementById('uploadStatus');
        const resultsDiv = document.getElementById('results');
        const resultsTable = document.getElementById('resultsTable');

        // Event listeners for file upload
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            dropZone.classList.add('drag-over');
        }

        function unhighlight() {
            dropZone.classList.remove('drag-over');
        }

        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                handleFile(files[0]);
            }
        }

        fileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                handleFile(this.files[0]);
            }
        });

        // File processing
        function handleFile(file) {
            if (!file) return;

            if (file.type !== 'text/xml' && !file.name.endsWith('.xml')) {
                showStatus('Error: Only XML files can be uploaded.', 'error');
                return;
            }

            showStatus('<span class="loading"></span> Loading file...', 'info');

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    xmlData = e.target.result;
                    parseXmlData(xmlData);
                    showStatus(`File ${file.name} loaded successfully.`, 'success');

                    // Analyze data and display results
                    analyzeAndDisplayResults();
                } catch (error) {
                    console.error('Error processing file:', error);
                    showStatus(`Processing error: ${error.message}`, 'error');
                }
            };

            reader.onerror = function() {
                showStatus('Error reading file.', 'error');
            };

            reader.readAsText(file);
        }

        // Helper for displaying status
        function showStatus(message, type) {
            uploadStatus.innerHTML = message;
            uploadStatus.className = `alert alert-${type}`;
            uploadStatus.style.display = 'block';
        }

        // Parse XML data
        function parseXmlData(xmlContent) {
            try {
                // Create DOM object from XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

                // Check for parsing errors
                const errorNode = xmlDoc.querySelector("parsererror");
                if (errorNode) {
                    throw new Error("Error parsing XML");
                }

                // Extract results
                const resultsNodes = xmlDoc.getElementsByTagName('Results');

                // Extract course configuration
                const courseDataNodes = xmlDoc.getElementsByTagName('CourseData');
                const courseConfigs = {};

                for (let i = 0; i < courseDataNodes.length; i++) {
                    const courseNr = courseDataNodes[i].getElementsByTagName('CourseNr')[0]?.textContent;
                    const config = courseDataNodes[i].getElementsByTagName('CourseConfig')[0]?.textContent;

                    if (courseNr && config) {
                        courseConfigs[courseNr] = config;
                    }
                }

                // Process results
                const results = [];

                for (let i = 0; i < resultsNodes.length; i++) {
                    const raceId = resultsNodes[i].getElementsByTagName('RaceId')[0]?.textContent;
                    const id = resultsNodes[i].getElementsByTagName('Id')[0]?.textContent;
                    const dtStart = resultsNodes[i].getElementsByTagName('dtStart')[0]?.textContent;
                    const dtFinish = resultsNodes[i].getElementsByTagName('dtFinish')[0]?.textContent;

                    // Check if we have GateTimes and Gates
                    const gateTimesNode = resultsNodes[i].getElementsByTagName('GateTimes')[0];
                    const gatesNode = resultsNodes[i].getElementsByTagName('Gates')[0];

                    if (raceId && dtStart && dtFinish && gateTimesNode && gatesNode) {
                        const gates = gatesNode.textContent.trim().split(/\s+/).filter(Boolean);
                        const gateTimes = gateTimesNode.textContent.split(';').filter(Boolean);

                        results.push({
                            raceId,
                            id,
                            dtStart,
                            dtFinish,
                            gates,
                            gateTimes
                        });
                    }
                }

                // Extract schedule for course information
                const scheduleNodes = xmlDoc.getElementsByTagName('Schedule');
                const scheduleInfo = {};

                for (let i = 0; i < scheduleNodes.length; i++) {
                    const raceId = scheduleNodes[i].getElementsByTagName('RaceId')[0]?.textContent;

                    if (raceId && raceId !== '<unassigned>') {
                        const courseNr = scheduleNodes[i].getElementsByTagName('CourseNr')[0]?.textContent;
                        const customTitle = scheduleNodes[i].getElementsByTagName('CustomTitle')[0]?.textContent;
                        const classId = scheduleNodes[i].getElementsByTagName('ClassId')[0]?.textContent;
                        const startTime = scheduleNodes[i].getElementsByTagName('StartTime')[0]?.textContent;

                        if (courseNr) {
                            scheduleInfo[raceId] = {
                                courseNr,
                                customTitle: customTitle || raceId,
                                classId: classId || '',
                                startTime: startTime || ''
                            };
                        }
                    }
                }

                // Store parsed data
                parsedData = {
                    results,
                    courseConfigs,
                    scheduleInfo
                };

                return true;
            } catch (error) {
                console.error('Error parsing XML:', error);
                throw error;
            }
        }

        // Analyze data and display results
        function analyzeAndDisplayResults() {
            // Get all available RaceIds
            const allRaceIds = parsedData.results.map(result => result.raceId);
            const uniqueRaceIds = [...new Set(allRaceIds)].sort();

            // Get maximum number of gates
            let maxGates = 0;
            parsedData.results.forEach(result => {
                if (result.gates.length > maxGates) {
                    maxGates = result.gates.length;
                }
            });

            // Map RaceId to course information
            const raceCourseMappings = {};
            for (const raceId of uniqueRaceIds) {
                if (parsedData.scheduleInfo[raceId]) {
                    raceCourseMappings[raceId] = parsedData.scheduleInfo[raceId].courseNr;
                }
            }

            // Structure to store analysis results
            const analysisResults = {};

            // Analysis for each RaceId
            for (const raceId of uniqueRaceIds) {
                const courseNr = raceCourseMappings[raceId];
                const courseConfig = parsedData.courseConfigs[courseNr] || '';

                // Get all runs for this RaceId
                const racesOfType = parsedData.results.filter(result => result.raceId === raceId);

                // Prepare array to store ex-post correction count for each gate
                const gateEdits = Array(maxGates).fill(0);

                // Identify segments
                const segments = [];
                let currentSegment = [];
                let segmentIndex = 0;

                if (courseConfig) {
                    for (let i = 0; i < courseConfig.length; i++) {
                        if (courseConfig[i] === 'S') {
                            if (currentSegment.length > 0) {
                                segments.push({
                                    gates: currentSegment,
                                    index: segmentIndex
                                });
                                currentSegment = [];
                                segmentIndex++;
                            }
                        } else {
                            currentSegment.push({
                                type: courseConfig[i],
                                gateIndex: i
                            });
                        }
                    }

                    // Add last segment if exists
                    if (currentSegment.length > 0) {
                        segments.push({
                            gates: currentSegment,
                            index: segmentIndex
                        });
                    }
                }

                // Analyze each run for this RaceId
                racesOfType.forEach(race => {
                    const { dtStart, dtFinish, gates, gateTimes } = race;

                    // Convert times to milliseconds from midnight
                    const startTimeMs = timeToMilliseconds(dtStart);
                    const finishTimeMs = timeToMilliseconds(dtFinish);

                    // Convert gate times to milliseconds
                    const gateTimeValues = gateTimes.map(time => parseInt(time, 10));

                    // Check if entry time is outside run interval or significantly different
                    for (let i = 0; i < gateTimeValues.length && i < gates.length; i++) {
                        const gateTimeMs = gateTimeValues[i];

                        // Check if time is outside run interval
                        // Adding small tolerance (30 seconds) for finish
                        const isOutsideRaceTime =
                            gateTimeMs < startTimeMs - 5000 || // 5 seconds before start
                            gateTimeMs > finishTimeMs + 30000; // 30 seconds after finish

                        // Is time significantly different from others?
                        let isSignificantlyDifferent = false;
                        if (gateTimeValues.length > 1) {
                            // Calculate median
                            const sortedTimes = [...gateTimeValues].sort((a, b) => a - b);
                            const median = sortedTimes[Math.floor(sortedTimes.length / 2)];

                            // Is difference greater than threshold (10 minutes = 600000 ms)?
                            isSignificantlyDifferent = Math.abs(gateTimeMs - median) > 600000;
                        }

                        // If time is suspicious, count it as ex-post correction
                        if (isOutsideRaceTime || isSignificantlyDifferent) {
                            gateEdits[i]++;
                        }
                    }
                });

                // Store analysis results
                analysisResults[raceId] = {
                    courseNr,
                    courseConfig,
                    gates: gateEdits,
                    segments: segments,
                    runsCount: racesOfType.length
                };
            }

            // Create table
            createResultsTable(analysisResults, maxGates);

            // Display results
            resultsDiv.style.display = 'block';

            // Event listener for copying table
            document.getElementById('copyToClipboard').addEventListener('click', () => {
                copyTableToClipboard(resultsTable);
            });
        }

        // Create results table
        function createResultsTable(analysisResults, maxGates) {
            resultsTable.innerHTML = '';

            // Create header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');

            // Empty cell for first column (RaceId)
            const thFirst = document.createElement('th');
            thFirst.textContent = 'Race';
            headerRow.appendChild(thFirst);

            // Header for each gate
            for (let i = 0; i < maxGates; i++) {
                const th = document.createElement('th');
                th.textContent = `${i + 1}`;
                th.className = 'cell-numeric';
                headerRow.appendChild(th);
            }

            thead.appendChild(headerRow);
            resultsTable.appendChild(thead);

            // Create table body
            const tbody = document.createElement('tbody');

            // Sort races by StartTime
            const sortedRaceIds = Object.keys(analysisResults).sort((a, b) => {
                const startTimeA = parsedData.scheduleInfo[a]?.startTime || '';
                const startTimeB = parsedData.scheduleInfo[b]?.startTime || '';

                return startTimeA.localeCompare(startTimeB);
            });

            // Create rows for each race
            for (const raceId of sortedRaceIds) {
                const raceData = analysisResults[raceId];

                // Row for race
                const raceRow = document.createElement('tr');
                raceRow.className = 'race-row';

                // First column - RaceId
                const raceIdCell = document.createElement('td');
                raceIdCell.textContent = raceId;
                raceRow.appendChild(raceIdCell);

                // Columns for each gate
                for (let i = 0; i < maxGates; i++) {
                    const td = document.createElement('td');
                    td.className = 'gate-cell cell-numeric';

                    if (i < raceData.gates.length) {
                        const editCount = raceData.gates[i];
                        if (editCount > 0) {
                            td.textContent = editCount;

                            // Color coding by correction count
                            if (editCount === 1) td.classList.add('level-1');
                            else if (editCount === 2) td.classList.add('level-2');
                            else if (editCount === 3) td.classList.add('level-3');
                            else if (editCount === 4) td.classList.add('level-4');
                            else if (editCount >= 5) td.classList.add('level-5');
                        } else {
                            td.textContent = '';
                            td.classList.add('level-0');
                        }
                    }

                    raceRow.appendChild(td);
                }

                tbody.appendChild(raceRow);
            }

            resultsTable.appendChild(tbody);
        }

        // Copy table to clipboard
        function copyTableToClipboard(table) {
            let tsv = '';

            // Iterate through all table rows
            for (let i = 0; i < table.rows.length; i++) {
                const row = table.rows[i];
                const rowData = [];

                // Iterate through all cells in row
                for (let j = 0; j < row.cells.length; j++) {
                    rowData.push(row.cells[j].textContent);
                }

                // Add row to TSV
                tsv += rowData.join('\t') + '\n';
            }

            // Copy to clipboard
            navigator.clipboard.writeText(tsv)
                .then(() => {
                    alert('Table copied to clipboard');
                })
                .catch(err => {
                    console.error('Error copying:', err);
                    alert('Failed to copy table to clipboard');
                });
        }

        // Function to convert time format (HH:MM:SS.mmm) to milliseconds from midnight
        function timeToMilliseconds(timeStr) {
            if (!timeStr) return 0;

            const parts = timeStr.split(':');
            if (parts.length < 3) return 0;

            const hours = parseInt(parts[0], 10);
            const minutes = parseInt(parts[1], 10);

            let seconds = 0;
            if (parts[2].includes('.')) {
                const secParts = parts[2].split('.');
                seconds = parseInt(secParts[0], 10);
                const milliseconds = parseInt(secParts[1], 10);
                seconds += milliseconds / 1000;
            } else {
                seconds = parseInt(parts[2], 10);
            }

            return (hours * 3600 + minutes * 60 + seconds) * 1000;
        }
    </script>
</body>
</html>
