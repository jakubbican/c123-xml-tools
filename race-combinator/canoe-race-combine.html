<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canoe Race Results Combinator</title>

    <!-- Google Fonts with system fallback -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Timing Design System z GitHub Pages -->
    <link rel="stylesheet" href="https://opencanoetiming.github.io/timing-design-system/dist/timing.min.css">

    <style>
        /* Override fonts - Google Fonts instead of self-hosted */
        :root {
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Sections */
        .input-section,
        .matching-section,
        .results-section {
            margin-bottom: var(--space-6);
            border-bottom: 1px solid var(--color-border);
            padding-bottom: var(--space-5);
        }

        .input-section h2,
        .matching-section h2,
        .results-section h2 {
            margin-bottom: var(--space-3);
        }

        .input-section p,
        .matching-section p {
            color: var(--color-text-secondary);
            margin-bottom: var(--space-4);
        }

        /* Dropzone customization */
        .dropzone p {
            margin-top: var(--space-2);
            color: var(--color-text-muted);
        }

        #fileList {
            margin-top: var(--space-3);
            color: var(--color-text-secondary);
            font-size: var(--text-sm);
        }

        #fileList div {
            padding: var(--space-1) 0;
        }

        /* Categories container */
        .categories-container {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-5);
            margin: var(--space-4) 0;
        }

        .category-box {
            flex: 1;
            min-width: 250px;
            max-width: 450px;
        }

        .category-box h3 {
            margin-bottom: var(--space-3);
        }

        /* Category list - custom scrollable area */
        .category-list {
            height: 200px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: var(--space-2);
            background-color: var(--color-bg-surface);
        }

        /* Category items */
        .category-item {
            padding: var(--space-2) var(--space-3);
            margin-bottom: var(--space-1);
            background-color: var(--color-bg-elevated);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .category-item:hover {
            background-color: var(--color-accent-subtle, rgba(0, 136, 255, 0.1));
        }

        .category-item.selected {
            background-color: var(--color-accent);
            color: #ffffff;
        }

        .category-item.selected .competitor-info {
            color: rgba(255, 255, 255, 0.8);
        }

        .category-item.paired {
            border-left: 4px solid var(--color-success);
            background-color: var(--color-success-subtle, rgba(0, 210, 106, 0.1));
        }

        .category-item.paired:hover {
            background-color: var(--color-success-subtle, rgba(0, 210, 106, 0.15));
        }

        .category-item.paired.selected {
            background-color: var(--color-accent);
            color: #ffffff;
        }

        .competitor-info {
            font-size: var(--text-xs);
            color: var(--color-text-muted);
            margin-top: var(--space-1);
        }

        /* Filter input */
        .filter-container {
            margin-bottom: var(--space-2);
        }

        .filter-container .input {
            width: 100%;
        }

        /* Count info */
        .count-info {
            margin-top: var(--space-2);
            font-size: var(--text-xs);
            color: var(--color-text-muted);
            text-align: right;
        }

        /* Match button center */
        .match-selected {
            display: flex;
            justify-content: center;
            margin: var(--space-4) 0;
        }

        /* Paired categories */
        .paired-categories-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-3);
        }

        .paired-categories-header h4 {
            margin: 0;
        }

        .pair-container {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            padding: var(--space-3);
            background-color: var(--color-bg-elevated);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            margin-bottom: var(--space-2);
        }

        .pair-item {
            flex: 1;
            padding: var(--space-2) var(--space-3);
            background-color: var(--color-bg-surface);
            border-radius: var(--radius-sm);
        }

        .pair-arrow {
            color: var(--color-accent);
            font-size: var(--text-xl);
            font-weight: var(--font-bold);
        }

        .remove-pair {
            background: transparent;
            border: none;
            color: var(--color-error);
            cursor: pointer;
            padding: var(--space-2);
            font-size: var(--text-lg);
            transition: opacity var(--transition-fast);
        }

        .remove-pair:hover {
            opacity: 0.7;
        }

        /* Navigation buttons */
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin: var(--space-5) 0;
            gap: var(--space-3);
        }

        /* Tabs - using timing design system */
        .tab-list {
            margin-bottom: var(--space-4);
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* Export buttons */
        .export-buttons {
            margin: var(--space-4) 0;
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .copy-success {
            color: var(--color-success);
            opacity: 0;
            transition: opacity var(--transition-normal);
        }

        .copy-success.show {
            opacity: 1;
        }

        /* Age category badge */
        .age-category {
            display: inline-block;
            padding: var(--space-0) var(--space-2);
            background-color: var(--color-info-subtle, rgba(0, 122, 255, 0.1));
            border-radius: var(--radius-sm);
            font-size: var(--text-xs);
            margin-left: var(--space-1);
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* Loading spinner */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--color-border);
            border-radius: 50%;
            border-top-color: var(--color-accent);
            animation: spin 1s ease-in-out infinite;
            margin-left: var(--space-2);
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Table improvements */
        .table th,
        .table td {
            white-space: nowrap;
        }

        .table td:nth-child(6) {
            white-space: normal;
            min-width: 150px;
        }

        /* Results section headings */
        .results-section h3 {
            margin-bottom: var(--space-3);
        }

        .results-section h4 {
            margin-top: var(--space-6);
            margin-bottom: var(--space-3);
            color: var(--color-text-secondary);
        }

        .results-section h5 {
            margin-top: var(--space-4);
            margin-bottom: var(--space-2);
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="card">
            <div class="card-body">
                <h1>Canoe Race Results Combinator</h1>

                <div class="input-section">
                    <h2>1. Upload XML Files</h2>
                    <p>Upload one or more XML files with race results.</p>

                    <div class="dropzone" id="dropZone">
                        <label for="xmlFile" class="btn btn-primary">Select files</label>
                        <input type="file" id="xmlFile" accept=".xml" multiple style="display: none;">
                        <p>or drag and drop files here</p>
                        <div id="fileList"></div>
                    </div>

                    <div id="uploadStatus" class="alert" style="display: none;"></div>

                    <div class="nav-buttons">
                        <div></div>
                        <button id="goToStep2" class="btn btn-primary" disabled>Continue to category pairing &rarr;</button>
                    </div>
                </div>

                <div class="matching-section hidden" id="step2">
                    <h2>2. Category Pairing for Combination</h2>
                    <p>Select categories you want to combine for the final ranking.</p>

                    <div class="categories-container">
                        <div class="category-box card">
                            <div class="card-body">
                                <h3>First Race</h3>
                                <div class="filter-container">
                                    <input type="text" class="input category-filter" id="filter1" placeholder="Filter categories...">
                                </div>
                                <div class="category-list" id="category1List"></div>
                                <div class="count-info" id="count1"></div>
                            </div>
                        </div>

                        <div class="category-box card">
                            <div class="card-body">
                                <h3>Second Race</h3>
                                <div class="filter-container">
                                    <input type="text" class="input category-filter" id="filter2" placeholder="Filter categories...">
                                </div>
                                <div class="category-list" id="category2List"></div>
                                <div class="count-info" id="count2"></div>
                            </div>
                        </div>
                    </div>

                    <div class="match-selected">
                        <button id="matchSelected" class="btn btn-primary" disabled>Pair selected categories</button>
                    </div>

                    <h3>Paired Categories</h3>
                    <div id="pairedCategories"></div>

                    <div class="nav-buttons">
                        <button id="backToStep1" class="btn btn-secondary">&larr; Back to file upload</button>
                        <button id="goToStep3" class="btn btn-primary" disabled>Generate results &rarr;</button>
                    </div>
                </div>

                <div class="results-section hidden" id="step3">
                    <h2>3. Combined Results</h2>

                    <div class="tab-list" id="resultTabs"></div>
                    <div id="tabContents"></div>

                    <div class="export-buttons">
                        <button id="copyToClipboard" class="btn btn-secondary">Copy current table to clipboard</button>
                        <span id="copySuccess" class="copy-success">Copied!</span>
                    </div>

                    <div class="nav-buttons">
                        <button id="backToStep2" class="btn btn-secondary">&larr; Back to category pairing</button>
                        <button id="startOver" class="btn btn-ghost">Start over</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for storing data
        let loadedFiles = [];
        let parsedData = {
            participants: {},
            results: {},
            classes: {},
            events: {},
            categories: {}
        };
        let availableCategories = [];
        let categoriesInfo = {};
        let pairedCategories = [];
        let combinedResults = {};

        // DOM elements
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('xmlFile');
        const fileList = document.getElementById('fileList');
        const uploadStatus = document.getElementById('uploadStatus');
        const goToStep2Button = document.getElementById('goToStep2');
        const category1List = document.getElementById('category1List');
        const category2List = document.getElementById('category2List');
        const matchSelectedButton = document.getElementById('matchSelected');
        const pairedCategoriesContainer = document.getElementById('pairedCategories');
        const goToStep3Button = document.getElementById('goToStep3');
        const resultTabs = document.getElementById('resultTabs');
        const tabContents = document.getElementById('tabContents');
        const copyToClipboardButton = document.getElementById('copyToClipboard');
        const copySuccess = document.getElementById('copySuccess');

        // Event listeners for navigation
        document.getElementById('goToStep2').addEventListener('click', () => {
            document.querySelector('.input-section').classList.add('hidden');
            document.getElementById('step2').classList.remove('hidden');
            populateCategoryLists();
        });

        document.getElementById('backToStep1').addEventListener('click', () => {
            document.getElementById('step2').classList.add('hidden');
            document.querySelector('.input-section').classList.remove('hidden');
        });

        document.getElementById('goToStep3').addEventListener('click', () => {
            document.getElementById('step2').classList.add('hidden');
            document.getElementById('step3').classList.remove('hidden');
            generateCombinedResults();
        });

        document.getElementById('backToStep2').addEventListener('click', () => {
            document.getElementById('step3').classList.add('hidden');
            document.getElementById('step2').classList.remove('hidden');
        });

        document.getElementById('startOver').addEventListener('click', () => {
            location.reload();
        });

        // Drag and drop for file upload
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        function highlight() {
            dropZone.classList.add('drag-over');
        }

        function unhighlight() {
            dropZone.classList.remove('drag-over');
        }

        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        fileInput.addEventListener('change', function() {
            handleFiles(this.files);
        });

        // Helper for displaying status
        function showStatus(message, type) {
            uploadStatus.innerHTML = message;
            uploadStatus.className = `alert alert-${type}`;
            uploadStatus.style.display = 'block';
        }

        function handleFiles(files) {
            if (files.length === 0) return;

            showStatus(`<span class="loading"></span> Loading ${files.length} file(s)...`, 'info');

            const filePromises = [];

            for (let i = 0; i < files.length; i++) {
                if (files[i].type !== 'text/xml' && !files[i].name.endsWith('.xml')) {
                    showStatus('Error: Only XML files can be uploaded.', 'error');
                    return;
                }

                const filePromise = readFile(files[i])
                    .then(content => {
                        loadedFiles.push({
                            name: files[i].name,
                            content: content
                        });
                        return parseXML(content, files[i].name);
                    });

                filePromises.push(filePromise);
            }

            Promise.all(filePromises)
                .then(() => {
                    updateFileList();
                    showStatus(`Successfully loaded ${loadedFiles.length} file(s).`, 'success');
                    goToStep2Button.disabled = false;

                    // Extract category information
                    extractCategories();
                })
                .catch(error => {
                    console.error('Error loading files:', error);
                    showStatus(`Processing error: ${error.message}`, 'error');
                });
        }

        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };

                reader.onerror = function() {
                    reject(new Error(`Cannot read file ${file.name}`));
                };

                reader.readAsText(file);
            });
        }

        function updateFileList() {
            fileList.innerHTML = '';

            loadedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.textContent = `${index + 1}. ${file.name}`;
                fileList.appendChild(fileItem);
            });
        }

        // Function to remove extension from ID
        function normalizeId(id) {
            // Remove everything after first dot (including dot)
            return id.split('.')[0];
        }

        function parseXML(xmlContent, fileName) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

                // Check for parsing errors
                const errorNode = xmlDoc.querySelector("parsererror");
                if (errorNode) {
                    throw new Error("Error parsing XML");
                }

                // Process participants
                xmlDoc.querySelectorAll('Participants').forEach(participant => {
                    const id = normalizeId(participant.querySelector('Id')?.textContent);
                    if (id) {
                        parsedData.participants[id] = {
                            id: normalizeId(id),
                            classId: participant.querySelector('ClassId')?.textContent,
                            eventBib: participant.querySelector('EventBib')?.textContent,
                            icfId: participant.querySelector('ICFId')?.textContent,
                            familyName: participant.querySelector('FamilyName')?.textContent,
                            givenName: participant.querySelector('GivenName')?.textContent,
                            club: participant.querySelector('Club')?.textContent,
                            ranking: participant.querySelector('Ranking')?.textContent,
                            birthdate: participant.querySelector('Birthdate')?.textContent,
                            year: participant.querySelector('Year')?.textContent,
                            catId: participant.querySelector('CatId')?.textContent,
                            source: fileName
                        };
                    }
                });

                // Process results
                xmlDoc.querySelectorAll('Results').forEach(result => {
                    const raceId = result.querySelector('RaceId')?.textContent;
                    const id = normalizeId(result.querySelector('Id')?.textContent);

                    if (raceId && id) {
                        if (!parsedData.results[raceId]) {
                            parsedData.results[raceId] = {};
                        }

                        parsedData.results[raceId][id] = {
                            id: normalizeId(id),
                            raceId: raceId,
                            startOrder: result.querySelector('StartOrder')?.textContent,
                            bib: result.querySelector('Bib')?.textContent,
                            status: result.querySelector('Status')?.textContent,
                            time: parseInt(result.querySelector('Time')?.textContent) || 0,
                            pen: parseInt(result.querySelector('Pen')?.textContent) || 0,
                            total: parseInt(result.querySelector('Total')?.textContent) || 999999,
                            totalBehind: result.querySelector('TotalBehind')?.textContent,
                            rnk: parseInt(result.querySelector('Rnk')?.textContent) || 999,
                            catRnk: parseInt(result.querySelector('CatRnk')?.textContent) || 999,
                            totalTotal: parseInt(result.querySelector('TotalTotal')?.textContent) || 999999,
                            totalRnk: parseInt(result.querySelector('TotalRnk')?.textContent) || 999,
                            totalCatRnk: parseInt(result.querySelector('TotalCatRnk')?.textContent) || 999,
                            catId: result.querySelector('CatId')?.textContent,
                            source: fileName
                        };
                    }
                });

                // Process classes
                xmlDoc.querySelectorAll('Classes').forEach(classNode => {
                    const classId = classNode.querySelector('ClassId')?.textContent;

                    if (classId) {
                        parsedData.classes[classId] = {
                            classId: classId,
                            class: classNode.querySelector('Class')?.textContent,
                            longTitle: classNode.querySelector('LongTitle')?.textContent,
                            categories: [],
                            source: fileName
                        };

                        // Process age categories
                        classNode.querySelectorAll('Categories').forEach(category => {
                            const catId = category.querySelector('CatId')?.textContent;

                            if (catId) {
                                const categoryData = {
                                    catId: catId,
                                    classId: category.querySelector('ClassId')?.textContent,
                                    category: category.querySelector('Category')?.textContent,
                                    firstYear: parseInt(category.querySelector('FirstYear')?.textContent) || 0,
                                    lastYear: parseInt(category.querySelector('LastYear')?.textContent) || 0
                                };

                                parsedData.classes[classId].categories.push(categoryData);

                                // Also store in categories for easier access
                                const catKey = `${classId}_${catId}`;
                                parsedData.categories[catKey] = categoryData;
                            }
                        });
                    }
                });

                // Process events
                xmlDoc.querySelectorAll('Events').forEach(event => {
                    const eventId = event.querySelector('EventId')?.textContent;

                    if (eventId) {
                        parsedData.events[eventId] = {
                            eventId: eventId,
                            mainTitle: event.querySelector('MainTitle')?.textContent,
                            location: event.querySelector('Location')?.textContent,
                            country: event.querySelector('Country')?.textContent,
                            startDate: event.querySelector('StartDate')?.textContent,
                            endDate: event.querySelector('EndDate')?.textContent,
                            source: fileName
                        };
                    }
                });

                // Process schedule
                xmlDoc.querySelectorAll('Schedule').forEach(schedule => {
                    const raceId = schedule.querySelector('RaceId')?.textContent;

                    if (raceId && raceId !== '<unassigned>') {
                        if (!parsedData.results[raceId]) {
                            parsedData.results[raceId] = {};
                        }

                        // Add race information to results
                        parsedData.results[raceId].scheduleInfo = {
                            raceId: raceId,
                            classId: schedule.querySelector('ClassId')?.textContent,
                            disId: schedule.querySelector('DisId')?.textContent,
                            startTime: schedule.querySelector('StartTime')?.textContent,
                            time: schedule.querySelector('Time')?.textContent,
                            customTitle: schedule.querySelector('CustomTitle')?.textContent,
                            source: fileName
                        };
                    }
                });

                return true;
            } catch (error) {
                console.error('Error parsing XML:', error);
                throw error;
            }
        }

        function extractCategories() {
            availableCategories = [];
            let dailyBestResults = {};

            // First determine which run (BR1, BR2) is better for each competitor
            // and store mapping of which raceId represents final results
            for (const raceId in parsedData.results) {
                if (parsedData.results[raceId].scheduleInfo) {
                    const { classId, disId } = parsedData.results[raceId].scheduleInfo;

                    // Check if this is second run (BR2)
                    if (disId === 'BR2') {
                        // Create key for daily combination (e.g. "C1Z_17")
                        const dayMatch = raceId.match(/(.+)_BR\d+_(\d+)$/);
                        if (dayMatch) {
                            const baseClass = dayMatch[1];
                            const day = dayMatch[2];
                            const dailyKey = `${baseClass}_${day}`;

                            // Record that BR2 is the final result for this day and category
                            dailyBestResults[dailyKey] = raceId;
                        }
                    }
                }
            }

            // Now process only relevant RaceIds (those representing final results)
            const processedClasses = new Set();

            for (const raceId in parsedData.results) {
                if (parsedData.results[raceId].scheduleInfo) {
                    const { classId, customTitle, source, disId } = parsedData.results[raceId].scheduleInfo;
                    const dayMatch = raceId.match(/(.+)_BR\d+_(\d+)$/);

                    // Skip BR1 runs if BR2 exists
                    if (dayMatch) {
                        const baseClass = dayMatch[1];
                        const day = dayMatch[2];
                        const dailyKey = `${baseClass}_${day}`;

                        // If BR2 exists and this is BR1, skip
                        if (dailyBestResults[dailyKey] && dailyBestResults[dailyKey] !== raceId) {
                            continue;
                        }
                    }

                    // For other cases, check if we've already processed this category for the day
                    let uniqueClassId = classId;
                    if (dayMatch) {
                        uniqueClassId = `${classId}_${dayMatch[2]}`;
                    }

                    if (processedClasses.has(uniqueClassId)) {
                        continue;
                    }
                    processedClasses.add(uniqueClassId);

                    // Count competitors in this category
                    let competitorCount = 0;
                    for (const id in parsedData.results[raceId]) {
                        if (id !== 'scheduleInfo') {
                            competitorCount++;
                        }
                    }

                    // Create category object
                    const categoryInfo = {
                        raceId: raceId,
                        classId: classId,
                        title: customTitle || classId,
                        source: source,
                        hasResults: competitorCount > 0,
                        competitorCount: competitorCount
                    };

                    // Add to list of available categories
                    availableCategories.push(categoryInfo);

                    // Store in map for easier lookup
                    categoriesInfo[raceId] = categoryInfo;
                }
            }

            // Sort categories by name
            availableCategories.sort((a, b) => {
                if (a.classId !== b.classId) {
                    return a.classId.localeCompare(b.classId);
                }
                return a.title.localeCompare(b.title);
            });
        }

        function populateCategoryLists() {
            category1List.innerHTML = '';
            category2List.innerHTML = '';

            // Setup filters
            const filter1 = document.getElementById('filter1');
            const filter2 = document.getElementById('filter2');

            filter1.addEventListener('input', function() {
                filterCategories(this.value, category1List, 'count1');
            });

            filter2.addEventListener('input', function() {
                filterCategories(this.value, category2List, 'count2');
            });

            availableCategories.forEach(category => {
                const item = document.createElement('div');
                item.className = 'category-item';
                item.dataset.raceId = category.raceId;

                let title = `${category.title} (${getRaceDay(category.raceId)})`;
                let subtitle = `Source: ${category.source} | Competitors: ${category.competitorCount || 0}`;

                item.innerHTML = `
                    <div>${title}</div>
                    <div class="competitor-info">${subtitle}</div>
                `;

                item.addEventListener('click', function() {
                    // Remove selection from all items in this list
                    Array.from(this.parentElement.children).forEach(el => {
                        if (el.classList.contains('category-item')) {
                            el.classList.remove('selected');
                        }
                    });

                    // Mark this item as selected
                    this.classList.add('selected');

                    // Check if both categories are selected
                    checkIfBothCategoriesSelected();
                });

                // Add to both lists for selection
                const item1 = item.cloneNode(true);
                item1.addEventListener('click', function() {
                    Array.from(this.parentElement.children).forEach(el => {
                        if (el.classList.contains('category-item')) {
                            el.classList.remove('selected');
                        }
                    });
                    this.classList.add('selected');
                    checkIfBothCategoriesSelected();
                });

                category1List.appendChild(item1);
                category2List.appendChild(item);
            });

            // Update counts
            document.getElementById('count1').textContent = `Total categories: ${availableCategories.length}`;
            document.getElementById('count2').textContent = `Total categories: ${availableCategories.length}`;
        }

        function filterCategories(query, categoryList, countId) {
            const items = categoryList.querySelectorAll('.category-item');
            const lowercaseQuery = query.toLowerCase();

            items.forEach(item => {
                const text = item.textContent.toLowerCase();
                if (text.includes(lowercaseQuery)) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });

            // Update visible categories count
            const visibleCount = Array.from(items).filter(item => item.style.display !== 'none').length;
            document.getElementById(countId).textContent = `Showing: ${visibleCount} of ${availableCategories.length}`;
        }

        function getRaceDay(raceId) {
            // Extract day from race ID (e.g. C1M_ST_BR1_6 => day 6)
            const dayMatch = raceId.match(/_(\d+)$/);
            return dayMatch ? `day ${dayMatch[1]}` : '';
        }

        function checkIfBothCategoriesSelected() {
            const cat1Selected = category1List.querySelector('.selected');
            const cat2Selected = category2List.querySelector('.selected');

            matchSelectedButton.disabled = !(cat1Selected && cat2Selected);
        }

        // Event listener for pairing selected categories
        matchSelectedButton.addEventListener('click', () => {
            const cat1Selected = category1List.querySelector('.selected');
            const cat2Selected = category2List.querySelector('.selected');

            if (cat1Selected && cat2Selected) {
                const cat1RaceId = cat1Selected.dataset.raceId;
                const cat2RaceId = cat2Selected.dataset.raceId;

                // Check if this combination is already paired
                const isDuplicate = pairedCategories.some(pair =>
                    (pair.race1 === cat1RaceId && pair.race2 === cat2RaceId) ||
                    (pair.race1 === cat2RaceId && pair.race2 === cat1RaceId)
                );

                if (!isDuplicate) {
                    // Add new pair
                    const newPair = {
                        id: Date.now(), // Unique ID for easy deletion
                        race1: cat1RaceId,
                        race2: cat2RaceId,
                        name: generateCombinedName(cat1RaceId, cat2RaceId)
                    };

                    pairedCategories.push(newPair);
                    updatePairedCategoriesList();

                    // Deselect
                    cat1Selected.classList.remove('selected');
                    cat2Selected.classList.remove('selected');
                    matchSelectedButton.disabled = true;

                    // Enable generate results button
                    goToStep3Button.disabled = pairedCategories.length === 0;
                }
            }
        });

        function generateCombinedName(race1Id, race2Id) {
            const race1Info = categoriesInfo[race1Id];
            const race2Info = categoriesInfo[race2Id];

            if (race1Info && race2Info) {
                // Trim name from trailing parts (day, run)
                let cleanTitle1 = race1Info.title
                    .replace(/\s*-\s*\d+\.\s*jízda\s*$/i, '') // Remove " - X. jízda" from end
                    .replace(/\s*\(den\s*\d+\)\s*$/i, '')     // Remove " (den X)" from end
                    .replace(/\s*\(day\s*\d+\)\s*$/i, '')     // Remove " (day X)" from end
                    .trim();

                let cleanTitle2 = race2Info.title
                    .replace(/\s*-\s*\d+\.\s*jízda\s*$/i, '')
                    .replace(/\s*\(den\s*\d+\)\s*$/i, '')
                    .replace(/\s*\(day\s*\d+\)\s*$/i, '')
                    .trim();

                // If names are the same, use only one
                if (cleanTitle1 === cleanTitle2) {
                    return `${cleanTitle1} - Combined`;
                } else {
                    return `${cleanTitle1}/${cleanTitle2} - Combined`;
                }
            }

            return 'Race Combination';
        }

        function updatePairedCategoriesList() {
            pairedCategoriesContainer.innerHTML = '';

            if (pairedCategories.length === 0) {
                pairedCategoriesContainer.innerHTML = '<p class="text-muted">No categories paired yet.</p>';
                return;
            }

            // Create header with count
            const headerElem = document.createElement('div');
            headerElem.className = 'paired-categories-header';
            headerElem.innerHTML = `<h4>Currently paired: ${pairedCategories.length} combination(s)</h4>`;
            pairedCategoriesContainer.appendChild(headerElem);

            pairedCategories.forEach(pair => {
                const pairElem = document.createElement('div');
                pairElem.className = 'pair-container';

                const race1Info = categoriesInfo[pair.race1];
                const race2Info = categoriesInfo[pair.race2];

                pairElem.innerHTML = `
                    <div class="pair-item">${race1Info.title} (${getRaceDay(pair.race1)})
                        <div class="competitor-info">Competitors: ${race1Info.competitorCount || 0}</div>
                    </div>
                    <div class="pair-arrow">+</div>
                    <div class="pair-item">${race2Info.title} (${getRaceDay(pair.race2)})
                        <div class="competitor-info">Competitors: ${race2Info.competitorCount || 0}</div>
                    </div>
                    <button class="remove-pair" data-id="${pair.id}" title="Remove">&#10006;</button>
                `;

                pairedCategoriesContainer.appendChild(pairElem);
            });

            // Add event listeners for pair removal buttons
            document.querySelectorAll('.remove-pair').forEach(button => {
                button.addEventListener('click', function() {
                    const pairId = parseInt(this.dataset.id);
                    pairedCategories = pairedCategories.filter(pair => pair.id !== pairId);
                    updatePairedCategoriesList();

                    // Disable generate results button if no pairs
                    goToStep3Button.disabled = pairedCategories.length === 0;

                    // Update visual indicators in lists
                    updateVisualIndicators();
                });
            });

            // Update visual indicators in lists
            updateVisualIndicators();
        }

        // Function to update visual indicators for already paired categories
        function updateVisualIndicators() {
            // Reset all indicators
            document.querySelectorAll('.category-item').forEach(item => {
                item.classList.remove('paired');
            });

            // Mark paired categories
            pairedCategories.forEach(pair => {
                document.querySelectorAll(`.category-item[data-race-id="${pair.race1}"]`).forEach(item => {
                    item.classList.add('paired');
                });

                document.querySelectorAll(`.category-item[data-race-id="${pair.race2}"]`).forEach(item => {
                    item.classList.add('paired');
                });
            });
        }


        function generateCombinedResults() {
            combinedResults = {};

            // Generate results for each category pair
            pairedCategories.forEach(pair => {
                const { race1, race2, name } = pair;

                // Get results from both races
                const results1 = parsedData.results[race1] || {};
                const results2 = parsedData.results[race2] || {};

                // Merge competitors from both races
                const allCompetitorIds = new Set();

                for (const id in results1) {
                    if (id !== 'scheduleInfo') {
                        allCompetitorIds.add(id);
                    }
                }

                for (const id in results2) {
                    if (id !== 'scheduleInfo') {
                        allCompetitorIds.add(id);
                    }
                }

                // Create combined results
                const competitorsResults = [];

                allCompetitorIds.forEach(id => {
                    const competitor = parsedData.participants[id];

                    if (competitor) {
                        // Results from first race
                        const result1 = results1[id] || {
                            rnk: 999,
                            catRnk: 999,
                            total: 999999,
                            totalTotal: 999999,
                            totalRnk: 999,
                            totalCatRnk: 999,
                            missing: true
                        };

                        // Results from second race
                        const result2 = results2[id] || {
                            rnk: 999,
                            catRnk: 999,
                            total: 999999,
                            totalTotal: 999999,
                            totalRnk: 999,
                            totalCatRnk: 999,
                            missing: true
                        };

                        // Use TotalRnk and TotalTotal if available (better time from both runs)
                        const rank1 = result1.totalRnk && !result1.missing ? result1.totalRnk : result1.rnk;
                        const rank2 = result2.totalRnk && !result2.missing ? result2.totalRnk : result2.rnk;

                        const catRank1 = result1.totalCatRnk && !result1.missing ? result1.totalCatRnk : result1.catRnk;
                        const catRank2 = result2.totalCatRnk && !result2.missing ? result2.totalCatRnk : result2.catRnk;

                        const time1 = result1.totalTotal && !result1.missing ? result1.totalTotal : result1.total;
                        const time2 = result2.totalTotal && !result2.missing ? result2.totalTotal : result2.total;

                        // Calculate combined ranking
                        const combinedRank = rank1 + rank2;
                        const combinedCatRank = catRank1 + catRank2;
                        const combinedTime = time1 + time2;

                        // Determine age category
                        const classId = competitor.classId;
                        const year = parseInt(competitor.year) || 0;
                        let ageCategory = competitor.catId || ''; // First try direct CatId
                        let ageCategoryName = '';

                        // If we don't have direct CatId, try to find by age
                        if (!ageCategory && parsedData.classes[classId]) {
                            const categories = parsedData.classes[classId].categories;

                            for (const cat of categories) {
                                if (year >= cat.firstYear && year <= cat.lastYear) {
                                    ageCategory = cat.catId;
                                    ageCategoryName = cat.category;
                                    break;
                                }
                            }
                        } else if (ageCategory) {
                            // If we have CatId, find category name
                            const catKey = `${classId}_${ageCategory}`;
                            if (parsedData.categories[catKey]) {
                                ageCategoryName = parsedData.categories[catKey].category;
                            }

                            // Another option - look directly in class
                            if (!ageCategoryName && parsedData.classes[classId]) {
                                const categories = parsedData.classes[classId].categories;
                                for (const cat of categories) {
                                    if (cat.catId === ageCategory) {
                                        ageCategoryName = cat.category;
                                        break;
                                    }
                                }
                            }
                        }

                        competitorsResults.push({
                            id,
                            name: `${competitor.givenName} ${competitor.familyName}`,
                            familyName: competitor.familyName,
                            givenName: competitor.givenName,
                            club: competitor.club,
                            year,
                            ageCategory,
                            ageCategoryName,
                            bib: competitor.eventBib || '',
                            regNum: competitor.icfId || '',
                            results: [
                                {
                                    rank: rank1,
                                    catRank: catRank1,
                                    time: time1,
                                    timeFormatted: time1 === 999999 ? '999' : formatTime(time1),
                                    missing: result1.missing || false
                                },
                                {
                                    rank: rank2,
                                    catRank: catRank2,
                                    time: time2,
                                    timeFormatted: time2 === 999999 ? '999' : formatTime(time2),
                                    missing: result2.missing || false
                                }
                            ],
                            combinedRank,
                            combinedCatRank,
                            combinedTime
                        });
                    }
                });

                // Sort results by combined ranking
                competitorsResults.sort((a, b) => {
                    // First by sum of rankings
                    if (a.combinedRank !== b.combinedRank) {
                        return a.combinedRank - b.combinedRank;
                    }

                    // Then by sum of times
                    return a.combinedTime - b.combinedTime;
                });

                // Add absolute ranking
                competitorsResults.forEach((competitor, index) => {
                    competitor.absoluteRank = index + 1;
                });

                // Split by age categories
                const ageCategoriesResults = {};

                competitorsResults.forEach(competitor => {
                    if (competitor.ageCategory) {
                        if (!ageCategoriesResults[competitor.ageCategory]) {
                            ageCategoriesResults[competitor.ageCategory] = {
                                name: competitor.ageCategoryName || competitor.ageCategory,
                                competitors: []
                            };
                        }

                        ageCategoriesResults[competitor.ageCategory].competitors.push(competitor);
                    }
                });

                // Sort age categories
                for (const catId in ageCategoriesResults) {
                    // Add ranking within category
                    ageCategoriesResults[catId].competitors.forEach((competitor, index) => {
                        competitor.categoryRank = index + 1;
                    });
                }

                // Save results
                combinedResults[name] = {
                    name,
                    race1Id: race1,
                    race2Id: race2,
                    race1Name: categoriesInfo[race1].title,
                    race2Name: categoriesInfo[race2].title,
                    allResults: competitorsResults,
                    ageCategories: ageCategoriesResults
                };
            });

            // Create tabs for results
            createResultTabs();
        }

        function formatTime(timeInMs) {
            if (timeInMs === 999999) return 'N/A';

            // Time is in milliseconds (e.g. 87660 = 87.66 seconds)
            const seconds = Math.floor(timeInMs / 1000);
            const milliseconds = timeInMs % 1000;

            // Format seconds and milliseconds
            return `${seconds}.${String(milliseconds).padStart(2, '0')}`;
        }

        function createResultTabs() {
            resultTabs.innerHTML = '';
            tabContents.innerHTML = '';

            // Create tabs for each combination
            let isFirst = true;

            for (const resultKey in combinedResults) {
                const result = combinedResults[resultKey];

                // Create tab
                const tab = document.createElement('button');
                tab.className = `tab ${isFirst ? 'active' : ''}`;
                tab.dataset.tabId = resultKey;
                tab.textContent = result.name;

                tab.addEventListener('click', function() {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-panel').forEach(c => c.classList.remove('active'));

                    this.classList.add('active');
                    document.getElementById(`content-${this.dataset.tabId}`).classList.add('active');
                });

                resultTabs.appendChild(tab);

                // Create tab content
                const content = document.createElement('div');
                content.className = `tab-panel ${isFirst ? 'active' : ''}`;
                content.id = `content-${resultKey}`;

                // Create results table
                content.innerHTML = createResultTable(result);

                tabContents.appendChild(content);

                isFirst = false;
            }

            // If no results
            if (Object.keys(combinedResults).length === 0) {
                tabContents.innerHTML = '<p>No results were generated.</p>';
            }
        }

        function createResultTable(result) {
            const { name, race1Name, race2Name, allResults, ageCategories } = result;

            // Shorten race names for columns
            const shortRace1Name = race1Name.replace(/\s-\s.*$/, ''); // Remove everything after first " - "
            const shortRace2Name = race2Name.replace(/\s-\s.*$/, '');

            let html = `
                <h3>${name}</h3>
                <p>Race combination: ${race1Name} + ${race2Name}</p>

                <div class="table-responsive">
                    <table class="table table-striped table-hover" id="table-${name.replace(/\s+/g, '-')}">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>VK #</th>
                                <th>VK</th>
                                <th>StČ</th>
                                <th>RGC</th>
                                <th>Name</th>
                                <th>Year</th>
                                <th>Club</th>
                                <th>1st #</th>
                                <th>1st time</th>
                                <th>2nd #</th>
                                <th>2nd time</th>
                                <th>∑ #</th>
                                <th>∑ time</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            // Add result rows
            allResults.forEach(competitor => {
                // Find ranking within age category
                let vkPor = '';
                if (competitor.ageCategory && ageCategories[competitor.ageCategory]) {
                    const categoryCompetitors = ageCategories[competitor.ageCategory].competitors;
                    const index = categoryCompetitors.findIndex(c => c.id === competitor.id);
                    if (index !== -1) {
                        vkPor = (index + 1) + '.';
                    }
                }

                html += `
                    <tr>
                        <td class="cell-numeric">${competitor.absoluteRank}.</td>
                        <td class="cell-numeric">${competitor.categoryRank || ''}${competitor.categoryRank ? '.' : ''}</td>
                        <td>${competitor.ageCategory || ''}</td>
                        <td>${competitor.bib || ''}</td>
                        <td>${competitor.regNum || ''}</td>
                        <td>${competitor.name}</td>
                        <td class="cell-numeric">${competitor.year || ''}</td>
                        <td>${competitor.club || ''}</td>
                        <td class="cell-numeric">${competitor.results[0].missing ? '999' : `${competitor.results[0].rank}.`}</td>
                        <td class="cell-numeric">${competitor.results[0].timeFormatted}</td>
                        <td class="cell-numeric">${competitor.results[1].missing ? '999' : `${competitor.results[1].rank}.`}</td>
                        <td class="cell-numeric">${competitor.results[1].timeFormatted}</td>
                        <td class="cell-numeric">${competitor.combinedRank}</td>
                        <td class="cell-numeric">${formatTime(competitor.combinedTime)}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            // Add tables for each age category
            if (Object.keys(ageCategories).length > 0) {
                html += `<h4>Results by Age Categories</h4>`;

                for (const catId in ageCategories) {
                    const category = ageCategories[catId];

                    html += `
                        <h5>${category.name || catId}</h5>
                        <div class="table-responsive">
                            <table class="table table-striped table-hover">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>StČ</th>
                                        <th>RGC</th>
                                        <th>Name</th>
                                        <th>Year</th>
                                        <th>Club</th>
                                        <th>1st #</th>
                                        <th>1st time</th>
                                        <th>2nd #</th>
                                        <th>2nd time</th>
                                        <th>∑ #</th>
                                        <th>∑ time</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;

                    category.competitors.forEach(competitor => {
                        html += `
                            <tr>
                                <td class="cell-numeric">${competitor.categoryRank}.</td>
                                <td>${competitor.bib || ''}</td>
                                <td>${competitor.regNum || ''}</td>
                                <td>${competitor.name}</td>
                                <td class="cell-numeric">${competitor.year || ''}</td>
                                <td>${competitor.club || ''}</td>
                                <td class="cell-numeric">${competitor.results[0].missing ? '999' : `${competitor.results[0].catRank}.`}</td>
                                <td class="cell-numeric">${competitor.results[0].timeFormatted}</td>
                                <td class="cell-numeric">${competitor.results[1].missing ? '999' : `${competitor.results[1].catRank}.`}</td>
                                <td class="cell-numeric">${competitor.results[1].timeFormatted}</td>
                                <td class="cell-numeric">${competitor.combinedCatRank}</td>
                                <td class="cell-numeric">${formatTime(competitor.combinedTime)}</td>
                            </tr>
                        `;
                    });

                    html += `
                                </tbody>
                            </table>
                        </div>
                    `;
                }
            }

            return html;
        }

        // Function to copy table to clipboard
        copyToClipboardButton.addEventListener('click', () => {
            // Find active tab and its table
            const activeTab = document.querySelector('.tab.active');
            if (!activeTab) return;

            const tabId = activeTab.dataset.tabId;
            const activeContent = document.getElementById(`content-${tabId}`);
            if (!activeContent) return;

            const table = activeContent.querySelector('.table');
            if (!table) return;

            // Convert table to TSV (Tab-Separated Values) for Excel
            let tsvContent = '';

            // Headers
            const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent);
            tsvContent += headers.join('\t') + '\n';

            // Rows
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = Array.from(row.querySelectorAll('td')).map(td => td.textContent);
                tsvContent += cells.join('\t') + '\n';
            });

            // Copy to clipboard
            navigator.clipboard.writeText(tsvContent)
                .then(() => {
                    // Show confirmation
                    copySuccess.classList.add('show');
                    setTimeout(() => copySuccess.classList.remove('show'), 2000);
                })
                .catch(err => {
                    console.error('Error copying to clipboard:', err);
                    alert('Failed to copy table to clipboard.');
                });
        });
    </script>
</body>
</html>
